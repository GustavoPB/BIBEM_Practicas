%
% Frontmatter - Introducción. Los miembros del tribunal que juzgan los PFC's tienen muchas más memorias que leer, por lo que
%	agradecerán cualquier detalle que permita facilitarles la vida. En este sentido, realizar una pequeña introducción,
%	comentar la organización y estructura de la memoria y resumir brevemente cada capítulo puede ser una buena práctica
%	que permita al lector centrarse fácilmente en la parte que más le interesa.
%

\chapter[Introduccion]{
	Introduccion
}
Genetic algorithms (GAs) belong to a family of stochastic search methods which is covered by the generic term Evolutionary Computation (EC). The main characteristic of EC techniques is that they computationally simulate the natural evolutionary process. The evolutionary process is modeled by the neo-Darwinian paradigm, which combines Darwinian evolution with Mendelian genetics. Other techniques covered by EC are evolution strategies (ESs) and evolutionary programming (EP).
The EC family of optimization techniques finds its place among other stochastic search and optimization approaches such as Simulated Annealing, Monte Carlo methods and Tabu search. These stochastic approaches were developed as an alternative to solving high-dimensional, discontinuous and multimodal problems, where traditional deterministic search techniques often proved ineffective. The disadvantage of these methods is that they don't guarantee to find the absolute best solution, but they do promise to find an acceptable solution in a reasonable amount of time.
A chromosome or an individual is an encoded candidate solution to a problem. It corresponds to a biological genotype. Chromosomes are typically represented as strings of some predefined alphabet A. The alphabet can be binary or non-binary. Typical examples of non-binary alphabets are real and integer numbers. The phenotype of an individual is the point in the solution space that this individual genotype maps to. A population is a set of individuals. Genes encode a particular element of the candidate solution. The values which a gene can take are called alleles.
***Figure search space solution space***
All evolutionary algorithms share a number of common properties. Firstly, all of them utilize the collective learning process of a population of individuals. Secondly, descendants of individuals are generated by randomized processes intended to model mutation and recombination occurring in nature. Lastly, by means of evaluating individuals in their environment, all individuals are assigned a measure of quality or fitness. This way, it is possible to make a comparison of individual fitness. This is the basis of the process of selection, which favors better individuals to reproduce more often than those relatively worse.
There are several basic differences in the utilization of these principles which make genetic algorithms different from the rest of the techniques of EC. Genetic algorithms emphasize recombination (crossover) as the most important search operator and apply mutation with a very small probability. They also use a probabilistic selection operator and often rely on the binary representation of individuals.
The general principle by which the genetic algorithm works is as follows. There exists a population of individuals where each individual represents one possible solution to the given problem. Each individual can be assigned a fitness measure by calculating the value of the function that is being optimized. The selection operator is used to choose those individuals in the population which are going to become the parents of the next generation. The parents produce children by means of the crossover operator, which emulates genetic recombination. Next the mutation operator is applied on the children. Lastly, the reinsertion operator is used to include children in the population of solutions, which closes the cycle of an algorithm.

Algorithm

General algorithm design
There are two typical genetic algorithm designs, the steady-state genetic algorithm and the generational genetic algorithm.
The steady-state genetic algorithm or incremental algorithm can be thought of as a simpler version of the generational genetic algorithm. At every cycle of the algorithm, two parents are chosen, the crossover operator is applied and a child is formed. The child is subsequently mutated and inserted in the population. Since the population size is maintained constant, the child replaces an individual in the old generation. The individual to be replaced is typically the worst one in the population.
Contrary to the steady-state genetic algorithm, the generational genetic algorithm makes a clear distinction between parents and children. At each algorithm cycle, a new generation, composed exclusively of children is formed and the old generation dies out.
In this practical assignment we have chosen to implement the steady-state algorithm with replacement of the worst individual in the population. The main reason against the generational approach is that absence of elitism would have made the convergence process slower. An additional reason for choosing the steady-state algorithm is the much lower computational cost needed to generate each generation of individuals. The scheme of the algorithm is shown in Figure ? and the pseudocode is shown in figure ?.
*** The scheme of the algorithm ***
*** The pseudocode of the algorithm ***


I'll have to add some modifications to the implementation so that the new generation is formed by choosing best individuals in the set of parents + children


Implementation
Class diagrams + explanations + code


Bibliography:
Redes de neuronas artificiales y computacion evolutiva
EAMOP
handbook of CE
Cupic(home university book)

%
% SECCION
%
%\subsection*{Estructura de la memoria}
%
%\paragraph*{Capítulo 1.}
%Resumen capítulo
%
%\paragraph*{Capítulo 2.}
%Resumen capítulo
%
%\paragraph*{Capítulo 3.}
%Resumen capítulo
%
%\paragraph*{Capítulo 4.}
%Resumen capítulo
%
%\paragraph*{Capítulo 5.}
%Resumen capítulo
%
%\paragraph*{Capítulo 6.}
%Resumen capítulo
%
%\paragraph*{Capítulo 7.}
%Resumen capítulo
%
%\paragraph*{Capítulo 8.}
%Resumen capítulo
%
%\paragraph*{Capítulo 9.}
%Resumen capítulo
%
%\paragraph*{Capítulo 10.}
Resumen capítulo